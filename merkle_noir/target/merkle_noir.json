{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":14283800841614961219,"abi":{"parameters":[{"name":"leaf","type":{"kind":"field"},"visibility":"private"},{"name":"path","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"selector","type":{"kind":"array","length":2,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/82ZTY/aMBCGDUkI4aOw0OW0UqXe2lP42A29IXW//0UKReqlqqqeq0jtDy8WnvAy66grZUbKSJGd+M0zw3jsNWzLHC06XIHrt1wfW+yH0Fprm2rbuDatadZfrOrjZq3E3Stxt0rcuQ53kepwMyUu5AGLPQJH9rkt/sCcFgXXoNbaX9cmrm3DeCAWfDpPmF9J/jpdfUk8n08w/mUCTAX+OmHzKsxPabP6XJzzDfMbMB1/BzW3oLkFDbLvQHNXobkHzX2F5gE0DxWaR9A8VmieQPNUoXkGzTPTDKFPRvmhOdRYQ4caXynXSDZkeTDwOcl3pON73WL+jDmvT8P894zqepy3mD+Kh+eH5npImuIUDx8Li5efg8YiGKP57R6ud6Dz1RbpPro+zZPmPqtV49amnvjRl7W4MKVRDgJ4Rrmk3HZRz8YSGAuLcz89dx+CH2RRHBHTf3D3I9d24B16f+zx32H+z+L2PON5STz6xKPvHK73rt83x/r5TXrzcl3Za+Pu01q2zHx7mBz/Zuvbp+T42YL4HZ385MSPdfLzifhdnfyU+0OiE395Tuqp8Bdl/fR18lP+DR/o5KfkD3X45fy+0cnPjvgjnfiviT/W4Zf724VOfsrvIROd+L8Sf6rCXyzoHPPWnIyfMS/hudzZYr577RmT/PdYrFpnzEsWD88PniPt2MwT69gzxvf4mcfPzOPHx5oKsoaCrFiQNRFkDQRZkrnvNDSuC0FWX5AVCbKaWqtjQZZkTfQaGlcoyBoJsppaE5LrMRFkNXVfDQRZdE73fa+3tnFtWtMo1tATa9sTK+l9v6/5zj4D0P74+e37L8MMHRMc+zQeVwRwxd4PKricj/fxf8avPCy7OKiow+Lc/8Y9T2tYtj5OjjX68Qv/u4oWwjjq/7h73JCpDWvEuc/y+X6Z7/PrfLdbbfMJ41trQ57+AXa1zvseHgAA","debug_symbols":"ndjBasJAEIDhd9lzDplNdnbWVymlRI0SCInEWCiSd28i2lKUQv6LOGZ/18PnZa5uX28vx4+mO/Rnt3m7urbfVWPTd/N0df720flUdct0HqthdJtSQ+bqbj+/M5kyd2ja2m3UT9nTUREf72dFNP85XOTT+zxsh6Ztm+PHnzvz5aUsXt3839dlrixBE0CjoImgMdCk9U3IQSOg8aABDgJwEICDABwE4CAABwE4UOBAgQMFDhQ4UOBAgQMFDhQ4UOBAgYMIHETgIAIHETiIwEEEDiJwEIGDCBxE4MCAAwMODDgw4MCAAwMODDgw4MCAAwMOEnCQgIMEHCTgIAEHCThIwEECDhJwkIADyXMSCYk8iQoSlSQKJFISRRIZiYgIISKEiBAiQogIISKEiBAiQogIISKEiPBEhH8pwrzdG1N5Svz6pFiflOuSaZ4+q6Gptm29LDOWh5du99htzOP4dXo8eWw/TkO/q/eXoV72IL8rkOXXFpKVcvt3zoN4zaSQ+ZL5om8=","file_map":{"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"62":{"source":"use dep::std::hash::poseidon2::Poseidon2;\n\nfn hash_pair(left: Field, right: Field) -> Field {\n    Poseidon2::hash([left, right], 2)\n}\n\nfn main(\n    leaf: Field,\n    path: [Field; 2],\n    selector: [bool; 2],\n    root: pub Field,\n) {\n    let mut digest = leaf;\n\n    for i in 0..2 {\n        let (left, right) = if selector[i] {\n            (path[i], digest)\n        } else {\n            (digest, path[i])\n        };\n        digest = hash_pair(left, right);\n    }\n    print(\"hola pa\");\n}\n\n#[test]\nfn should_verify_merkle_inclusion() {\n    let leaf = 0x0b6423c65de8971f0643ab09e384b6009ccf91afc59eb82b3f762d3b068f3be6;\n    let path: [Field; 2] = [\n        0x2c89cbf002f98b27bed8c22279d920ec121130909ccb798b59e775f567f2eef6,\n        0x232cffccaefe9c394f4aada19e5b0599b85de274e62074a686431b608c468c94\n    ];\n    let directions: [bool; 2] = [false, true];\n    let root = 0x0a75936c9198aa238464d75b9f441788683d16a315c428c60160c24566d010a9;\n\n    main(leaf, path, directions, root);\n}\n","path":"/Users/francoperez/repos/zk/noir-class-01/merkle_noir/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained"]}